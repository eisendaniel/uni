

/*
 ============================================================================
 Name        : part1.txt
 Author      : Abdullah Alasmari
 Version     :
 Copyright   : Your copyright notice
 ============================================================================
 */
 
Task 1: 

Core:

[1]

(a) while: invalid C identifier, it is a reserved keyword

(b) record_100: valid C identifier

(c) $record: invalid C identifier, in C, $ is not allowed for identifiers

(d) integer-counter: invalid C identifier, - is not a 'number', 'character' or ' _ '  

-------------------------

[2]

(a) a + b + c  = 15 

(b) a / b = 2 (decimal part is truncated)

(c) a % b = 1 

(d) a * b % c = 1 (Multiplication will happen first, the % after)

-------------------------

[3]
Assuming that we will store the result in :
- integer variable, ex: (int r = expressions;)
- char variable, ex: (char x = expressions;)

(a) c1 + c2 + c3  :  result r = 183 , x = -73

(b) c1 - ’A’      :  result r = 3   , x =  3

(c)3 * c2         :  result r = 156 , x = -100

(d) ’3’ * c2.     :  result r = 2652 , x = 92
=============================================

Task 2: 

Completion:

[1]

compiler automatically converts any
intermediate values to the proper type so that the expression can be
evaluated without losing any significance. for ex, if we store the result of this expression
in a variable of type 'int' the compiler automatically converts the result of the expression to type 'int'. 


[2]

the value assigned to k = 8 
k = (j > 5) ? i : j;  // if j is grater than 5, then k = i, otherwise k = j. 


[3]

problems: 

- Mathematically,  division by zero is undefined. we will get a warning.  

- The modulus % operator only works on integers. if we are not dividing by 0, we can simply add pracets () like this :  int rem = 10.0 / (x % y);
 or we can do some Type Casting as long as we are not dividing by zero. 


[4]

int main (void)
{
for(int j = 5; j >= 0;) 
printf("%d ",--j );
return 0;
}


---------------------------

Task 3 : 

[1]

int i = 5, j = 10, k = 1;
(k += 3*--i) - j++;

i = 4 , j = 11 , k = 13


[2]

   char string[] = "One\0Two\0Three"; 
   printf("%d", strlen(string));
   
   strlen : returns length of the string, not counting the ‘\0’. however; 
   
   The program will print only the length of string “One”. 
   
- The '\0' character terminates the string
– What comes after, does not matter























